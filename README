Features :
Serveur : 
- Les fichiers socket_client.py & socket_serveur.py sont la première itération de l'intéraction client/serveur, l'envoi d'un seul message est possible (client -> bonjour -> déconnexion)
- Les fichiers socket_serveur_chat.py & clientA.py permettent d'envoyer plusieurs messages avec réception du serveur, accueil des clients et réponse aux clients (sans que le serveur se déconnecte. 
  Le serveur reste en écoute et n'a pas de limitation de connexions clients (problème : impossible de déterminer qui est l'émetteur du message)
 Jeu :
 - Le fichier jeu.py contient la définition des classes Joueur (nom du joueur & liste de pokemons) et Pokemon (attributs du pokemon) ; le fichier joueurs_bdd.json contient la liste des
  joueurs ayant déjà joué ou dont la première partie est en cours (TODO : bdd à reformatter en suivant le format du pokedex).
  Le jeu en lui-même permet de récupérer le nom de joueur choisit (input utilisateur) pour voir s'il existe en BDD :
    - si oui, on récupère ses informations depuis le joueurs_bdd.json et on envoie ces données dans nos classes
    - si non, on choisit de manière aléatoire trois pokemons depuis notre pokedex.json et on les envoie dans nos classes
    
 Start :
 - Communication : socket_srveur_chat.py & clientA.py
 - Jeu : jeu.py

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Plan : 
Repartition du projet endeux parties :
- Un groupe sur le jeu en lui-même :
  - chaque client choisit un nom d'utilisateur envoyé au serveur : récupération données joueur envoyées au client ou création du joueur alétoirement
  - le serveur gère l'état de la partie (états des joueurs et de leurs pokemons) et envoie les données au format JSON pour permettre l'affichage 
    de la partie aux clients
  - le client reçoit les données de la partie en cours par le serveur, gère l'affichage en fonction de ces données, récupère l'action du joueur pour le tour,
    évalue les données et met à jour le partie, renvoie l'état de la partie au client, puis envoie état de la partie au client adverse
    joueur1 -> input -> serveur -> traitement données -> réponse joueur1 -> affichage -> code HTTP 200 OK -> envoie données actuelles de la partie joueur2 
    -> début tour joueur2
   - en cas de fin de partie, le serveur envoie dans la bdd l'état des joueurs actuel
- Un autre goupe sur l'infra (client <-> [serveur -> bdd] <-> client)
  - implémentation de la classe http en python
  - le serveur exécute en tache de fond le programme python qui gère la partie et intéragit avec la bdd


joueur1 -> input -> serveur -> traitement données -> réponse joueur1 -> affichage -> code HTTP 200 OK -> envoie données actuelles de la partie joueur2 -> début tour joueur2
                                    
                                 
